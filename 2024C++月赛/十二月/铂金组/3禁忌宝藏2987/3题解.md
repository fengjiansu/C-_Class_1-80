## 题目简述

给定 \(n\) 个正整数（表示宝石编号）和一个整数 \(k\)（禁忌系数），需要从中选择一个最大的子集，使得子集中没有两个元素 \(x\) 和 \(y\) 满足 \(y = k \cdot x\)。输出满足条件的最大子集的大小。

---

## 题目分析

本题需要从宝石编号集合中选择尽可能多的宝石，同时满足禁忌规则：对于集合中的任意元素 \(x\)，不能存在另一个元素 \(y = k \cdot x\)。  
为了解决这个问题，可以采取以下思路：

1. **排序**：
   - 按照从小到大的顺序排序宝石编号，有助于按递增顺序选择宝石，并避免较大的宝石因倍数关系被筛掉。

2. **贪心选择**：
   - 对于每个编号 \(a[i]\)，如果它不能整除 \(k\) 或者它的倍数关系 \(a[i]/k\) 不在已选中的集合中，那么 \(a[i]\) 可以被选入集合。

3. **使用集合去重**：
   - 通过集合记录已选中的宝石编号，避免重复计算，并高效判断是否存在 \(a[i]/k\)。

---

## 解题思路

1. 将输入的宝石编号存入数组。
2. 对数组进行升序排序，保证较小的编号优先被处理。
3. 遍历排序后的数组：
   - 如果当前编号 \(a[i]\) 不能整除 \(k\) 或者它的倍数关系 \(a[i]/k\) 不在集合中，则将其加入集合。
4. 遍历结束后，集合的大小即为满足条件的最大子集的大小。

---

## 代码实现

```cpp
#include <iostream>
#include <cstdio>
#include <set>
#include <algorithm>
using namespace std;

long long a[100005]; // 存储宝石编号
set<long long> A;    // 记录已选中的编号
int n, k;

int main() {
    scanf("%d%d", &n, &k); // 输入宝石数量和禁忌系数
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]); // 输入宝石编号
    }

    sort(a + 1, a + 1 + n); // 按升序排序
    for (int i = 1; i <= n; i++) {
        // 如果当前编号不能整除 k 或者其倍数关系不在集合中
        if (a[i] % k || A.find(a[i] / k) == A.end()) {
            A.insert(a[i]); // 将当前编号加入集合
        }
    }

    printf("%d\n", A.size()); // 输出集合大小
    return 0;
}
## 常见问题和优化

1. **为何使用排序？**
   - 排序后可以从小到大处理编号，确保每次判断时，较大的编号会因较小编号已加入集合而被过滤掉，从而避免不必要的重复。

2. **贪心选择的正确性**：
   - 贪心算法保证了优先选择较小编号。如果较小编号的倍数关系不在集合中，那么选择当前编号是安全的，不会违反禁忌规则。

3. **集合判断效率**：
   - 集合的插入和查找操作均为 \(O(\log n)\)，结合整体排序的时间复杂度 \(O(n \log n)\)，总复杂度为 \(O(n \log n)\)。

4. **特殊情况处理**：
   - 当 \(k = 1\) 时，任何编号的倍数关系都满足 \(y = k \cdot x = x\)，此时答案为 1。

---

## 总结与拓展

1. **本题的贪心思想**：
   - 贪心的核心在于尽可能优先选择较小的编号，避免因倍数关系排除过多可选编号。

2. **类似问题**：
   - 「数论」相关问题中，往往涉及因数、倍数关系的筛选和判断，可以借鉴贪心与排序结合的思路。

3. **拓展应用**：
   - 可以将问题进一步推广到多因子限制，或者更复杂的禁忌规则场景，增加选择的灵活性。
