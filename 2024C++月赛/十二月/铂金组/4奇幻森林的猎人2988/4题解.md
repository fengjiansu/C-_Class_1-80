## 题目简述

给定一个长度为 \(n\) 的整数数组 \(nums\)，以及一个整数 \(k\)，任务是找到每个长度为 \(k\) 的子数组中的最大值，依次输出所有子数组的最大值。

---

## 题目分析

1. **滑动窗口问题**：
   - 本题的目标是在给定的数组中，计算每个长度为 \(k\) 的子数组的最大值。
   - 滑动窗口方法可以高效地解决此类问题，通过动态维护一个窗口中的最大值，避免重复计算。

2. **优先队列（最大堆）**：
   - 使用优先队列存储当前窗口中的元素及其索引。
   - 堆顶元素始终是当前窗口的最大值。
   - 为确保堆顶元素在当前窗口范围内，每次移动窗口时需要移除不在窗口范围内的元素。

3. **时间复杂度分析**：
   - 遍历数组一次，每个元素最多进堆和出堆各一次，复杂度为 \(O(n \log k)\)。

---

## 解题思路

1. **初始化**：
   - 将数组的前 \(k\) 个元素加入优先队列，并记录堆顶的最大值。

2. **滑动窗口遍历**：
   - 从第 \(k+1\) 个元素开始，逐个将新元素加入优先队列，同时移除不在窗口范围内的元素。
   - 更新堆顶的最大值，记录到结果数组中。

3. **输出结果**：
   - 遍历结束后，结果数组中存储了每个滑动窗口的最大值，按顺序输出。

---

## 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<double> vd;
typedef pair<int, int> pii;
#define F first
#define S second
#define MP make_pair
#define PB push_back
#define REP(i, a, b) for (int i = a; i < b; i++)
#define RFOR(it, c) for (auto &it : c)

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for(int i = 0; i < n; ++i)
    {
        cin >> nums[i];
    }
    priority_queue<pair<int, int>> q;
    for (int i = 0; i < k; ++i)
    {
        q.emplace(nums[i], i);
    }
    vector<int> ans = {q.top().first};
    for (int i = k; i < n; ++i)
    {
        q.emplace(nums[i], i);
        while (q.top().second <= i - k)
        {
            q.pop();
        }
        ans.push_back(q.top().first);
    }
    for (auto& i : ans)
        cout << i << " ";
    return 0;
}
## 常见问题和优化

1. **滑动窗口的正确性**：
   - 通过优先队列动态维护当前窗口的最大值，并确保移除窗口外的元素，保证结果的正确性。
   - 在处理窗口边界时，需注意条件 `q.top().second <= i - k`，确保堆顶元素在当前窗口内。

2. **优先队列的效率**：
   - 插入和删除操作的复杂度为 \(O(\log k)\)，在 \(n\) 次操作中效率较高。
   - 当 \(k\) 较大时，优先队列的性能可能受影响，可以考虑使用单调队列优化到 \(O(n)\)。

3. **空间优化**：
   - 优先队列需要额外的 \(O(k)\) 空间存储堆内元素。
   - 如果内存紧张，可用单调队列替代优先队列，减少空间开销。

4. **其他注意事项**：
   - 如果 \(k = 1\)，每个子数组的最大值就是元素本身，无需复杂计算。
   - 如果 \(k \geq n\)，结果只有一个值，即整个数组的最大值。

---

## 总结与拓展

1. **滑动窗口思想**：
   - 滑动窗口的核心是动态维护窗口内的状态（如最大值、最小值、总和等），在窗口移动过程中保证高效更新。
   - 通过结合数据结构（如优先队列或单调队列）实现窗口的高效操作。

2. **类似问题**：
   - **滑动窗口的最小值**：动态维护窗口内的最小值，可以使用与本题相同的思路。
   - **滑动窗口中的和或乘积**：可以通过前缀和或动态维护来实现。

3. **单调队列优化**：
   - 使用单调队列替代优先队列，可以将时间复杂度从 \(O(n \log k)\) 优化到 \(O(n)\)。
